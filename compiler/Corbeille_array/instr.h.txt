#pragma once

#include <string>
#include <vector>
#include "./symbol-table/Context.h"
#include "expr.h"
#include "IR.h"

using namespace std;

/*
typedef enum
{
	int64,
	int32
} Type;
*/

typedef enum
{
	AFF,
	//    DECL,
	// DECLAFF,
	RET,
	IF,
	WHILE,
	FOR,
	FUNCCALL
} Instruction;

class Node
{
public:
	virtual string buildIR(CFG* cfg) {return "buildNode";}
	virtual void debug(ostream &stream, int space) {}
	void showSpaces(ostream &stream, int space)
	{
		for (int i = 0; i < space; ++i)
		{
			stream << "  ";
		}
	}
};

class Instr : public Node
{
public:
	Instr(Instruction inst) : instruction(inst)
	{
	}
	//virtual string buildIR(CFG* cfg) override;
	Instruction instruction;
};

class Block : public Node
{
public:
	Block(Context *c) : context(c)
	{
	}
	void addInstr(Instr *instr);
	virtual void debug(ostream &stream, int space) override;
	virtual string buildIR(CFG* cfg) override;
	vector<Instr *> instrs;
	Context *context;
};

class Func : public Node
{
public:
	Func(TypeName t, string n, Block *b) : type(t), name(n), block(b)
	{
	}
	void addParam(string param);
	void addInstr(Instr *instr);
	virtual void debug(ostream &stream, int space) override;
	virtual string buildIR(CFG* cfg) override;
	TypeName type;
	string name;
	vector<string> params;
	Block *block;
};

class Aff : public Instr, public Expr
{
public:
	Aff(string id, Expr *ex) : Instr(AFF), varId(id), expr(ex)
	{
	}
	virtual void debug(ostream &stream, int space) override;
	virtual string buildIR(CFG* cfg) override;
	string varId;
	Expr *expr;
};

class ArrAff : public Aff
{
public:
	ArrAff(string id, Expr *ex, Expr* i) : Aff(id,ex), index(i)
	{
	}
	//virtual void debug(ostream &stream, int space) override;
	//virtual string buildIR(CFG* cfg) override;
	Expr* index;
};

class ArrDef : public Instr
{
	public:
	ArrDef(TypeName t, string s, Expr* e) : Instr(AFF),type(t), name(s), expr(e) {}
	virtual void debug(ostream &stream, int space) override;
	virtual string buildIR(CFG* cfg) override;
	TypeName type;
	string name;
	Expr* expr;
};

class ArrayAccess : public Expr, public Instr
{
	public:
	ArrayAccess(string s, Expr* e): Instr(AFF), arrayName(s), index(e) {}
	virtual string buildIR(CFG* cfg) override;
	virtual void debug(ostream &stream, int space) override
	{
		stream << "array at " << arrayName;
	}
	string arrayName;
	Expr* index;
};
/*
   class Decl : public Instr {
    Decl(int t, string id) : Instr(DECL), type(t), varId(id) {}
    int type;
    string varId;
   };
 */

/*class DeclAff : public Instr {
   public:
   DeclAff(string id, Expr ex) : Instr(DECLAFF), varId(id), expr(ex) {
   }
   virtual string buildIR(CFG* cfg) override;
   string varId;
   Expr expr;
   };*/

class Ret : public Instr
{
public:
	Ret(Expr *ex) : Instr(RET), expr(ex)
	{
	}
	virtual void debug(ostream &stream, int space) override;
	virtual string buildIR(CFG* cfg) override;
	Expr *expr;
};

class If : public Instr
{
public:
	If(Expr *cond, Block *bif, Block *belse) : Instr(IF), condition(cond),
																						 blockIf(bif), blockElse(belse)
	{
	}
	void addInstrIf(Instr *instr);
	void addInstrElse(Instr *instr);
	virtual void debug(ostream &stream, int space) override;
	//virtual string buildIR(CFG* cfg) override;
	Expr *condition;
	Block *blockIf;
	Block *blockElse;
};

class While : public Instr
{
public:
	While(Expr *cond, Block *b) : Instr(WHILE), condition(cond), block(b)
	{
	}
	void addInstr(Instr *instr);
	//virtual string buildIR(CFG* cfg) override ;
	void debug(ostream &stream, int space);
	Expr *condition;
	Block *block;
};

class For : public Instr
{
public:
	For(Expr *i, Expr *cond, Expr *p, Block *b) : Instr(FOR), init(i), condition(cond), progression(p), block(b)
	{
	}
	void addInstr(Instr *instr);
	//virtual string buildIR(CFG* cfg) override;
	Expr *init;
	Expr *condition;
	Expr *progression;
	Block *block;
};

class FuncCall : public Instr, public Expr
{
public:
	FuncCall(string fn) : Instr(FUNCCALL), funcName(fn)
	{
	}
	void addParam(Expr *param);
	virtual void debug(ostream &stream, int space) override;
	//virtual string buildIR(CFG* cfg) override;
	string funcName;
	vector<Expr *> params;
};
